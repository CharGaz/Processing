/* autogenerated by Processing revision 1293 on 2024-11-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;
import g4p_controls.*;
import java.io.File;
import java.io.InputStreamReader;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Processing extends PApplet {

//Importing Libraries





//Importing Images
PImage soundImg;
PImage speedImg;
PImage logo;

//Creating boolean variables
boolean playSong = false;
boolean playStatus = false;
boolean displayPlay = true;
boolean isLooping = false;
boolean delete = false;
boolean create = false;



//Creating Arraylists for all the playlist/songs
ArrayList<ArrayList<Song>> allPlaylists = new ArrayList<ArrayList<Song>>(); //2D arraylist to hold all playlists
ArrayList<Song> defaultPlaylist = new ArrayList<Song>(); //Defualt playlist with all the songs
ArrayList<Song> playlist1 = new ArrayList<Song>(); //Another set playlist 
ArrayList<Song> playlist2 = new ArrayList<Song>(); //Another set playlist 

ArrayList<Song> playlist; //Arraylist that will hold the songs of the current playlist
ArrayList<Song> selectedSongs = new ArrayList<Song>(); // Arraylist that will hold the selected songs by the user when making a new playlist

ArrayList<String> displayNames = new ArrayList<String>();//Arraylist to hold the names of the playlists


//Int values
int songIndex = 0;
int loopIndex = 1;
int selectedIndex;
int playlistCounter = 3;

//Float values
float playBackSpeed = 1.0f;
float setVolume = 0.9f;

// Audio Analyzer Setup
int bands;
float[] spectrum;
AudioIn in;
FFT fft;
AudioVisualizer audioVisualizer;

String youtubeURL;

public void setup(){
  //Setting up background and size of the canvas:
  /* size commented out by preprocessor */;
  background(197, 211, 232);
  frameRate(120);

  
  initializePlaylists(); //Initializeds all the playlists
  setActivePlaylist(0); //Sets the active playlist to all songs

  

  bands = 512;
  spectrum = new float[bands];
  fft = new FFT(this, bands);
   
  audioVisualizer = new AudioVisualizer(950, width-25);
    
  createGUI(); //Creating thew GUI

  //Loading the images into the sketch
  soundImg = loadImage("Audio button.png");
  speedImg = loadImage("Stop Watch.png");
  logo = loadImage("logo.png");
  
}

public void draw(){
  //Drawing the background, images and songs
  background(158, 163, 210);
  drawUI();
  image(soundImg,880,530, 48,48);
  image(speedImg, 881, 480, 39, 39);
  image(logo,0,45, 190,50);
  drawSongs();
  
  //Displaying the info of the songs(Title, Album and Album Cover)
  if(playlist.size() > 0){
      //playlist.get(songIndex).displayInfo(this);
    }

  

   playlist.get(songIndex).playSong(playBackSpeed, setVolume);//Putting the playback speed and volume into the song class
  
  if(!playlist.get(songIndex).song.isPlaying() && playStatus){ //Checking if a songs is playing
    
    playStatus = false;
    if(!isLooping){ //Checking if the user wants the song to be looping
      songIndex = (songIndex + 1) % playlist.size(); //If not looping, plays next song
    }

    
    
  }
  audioVisualizer.update(); //Updating Audio Visulizer

  
}

public void setActivePlaylist(int index){ //Switches between the playlists
  if(index >= 0 && index < allPlaylists.size()){

    if(playlist != null && playlist.size() > 0 && playlist.get(songIndex).song.isPlaying()){ //Stoping the song when it switches playlists
      playlist.get(songIndex).stopSong();
      
    }
    playStatus = false; // Reset play status
    playSong = false; //Pauses the songs
    displayPlay = true; //Displays the play button to indicate pause

    playlist = allPlaylists.get(index); //Putting the requested playlists song into arraylist that will be used by program
    songIndex = 0; // Reset songIndex when switching playlists
  } 
}

public void drawUI(){
  // left frame
  fill(158, 163, 210);
  strokeWeight(0);
  rect(0, 0, 200, height);
  
  // bottom frame
  fill(184,186,204);
  rect(200, height - 150, 925, height - 150);

  //Bottom right frame:
  fill(209,211,234);
  rect(925,300, width, height);

  //right frame
  strokeWeight(0);
  rect(925,0, width, height);
  
  // divisor lines
  stroke(2, 1, 10);
  fill(2, 1, 10);
  strokeWeight(2);
  rect(200, 0, 5, height);    // left line
  rect(205, height - 150, 723, 5);    // bottom line
  rect(925, 0, 5, height); //right line
  rect(925,300, width, 5); // right panal divisor
  rect(0,190, 200,5); //left panal dvisor
  
  //Having either play or pause button on the screen at one given time
  if(displayPlay){
    play_button.setVisible(true);
    pause_button.setVisible(false);
  }
  else{
    play_button.setVisible(false);
    pause_button.setVisible(true);
  }


  //Changing the loop button from black(off) to white(on)
  if((loopIndex % 2) == 0){
    loop_button.setVisible(false);
    loop_buttonWhite.setVisible(true);
  }

  else{
    loop_button.setVisible(true);
    loop_buttonWhite.setVisible(false);

  }

  //Having the delete playlist screen come up
  if(delete){
    returnButton.setVisible(true);
    deletePlaylist();
  }
 
  //Having the create playlist screen come up
  else if(create){
    returnButton.setVisible(true);
    confirmButton.setVisible(true);
    playlistCreateDisplay();
    

  }
  else{
    returnButton.setVisible(false);
    confirmButton.setVisible(false);
  }
}

public void drawSongs(){
  if(!delete){
    int x = 275; //Setting base x and y values 
    int y = 50;

    for(int i = 0; i < playlist.size(); i++){ //Checking how many songs are in the playlist
      playlist.get(i).printSongs(this,x,y); //Inputs all song info into printSongs function
      noFill();
      strokeWeight(5);
      rect(x-40,y-25, 125,50);
      x += 180; //Moves x over by 200 every time
      
      if(x > 900){
        x = 275; //When x reaches the end of panal, it resest to the start
        y += 75; //When x resets, y moves down to create a new row
      }
    }
  }
}

public void getYoutubeWindows(String url){
  try {
    String downloadPath = sketchPath("data");
    String[] commands = {"yt-dlp", "-o", downloadPath + "/%(title)s.%(ext)s", "--extract-audio", "--audio-format", "mp3", url};    
    ProcessBuilder processBuilder = new ProcessBuilder(commands);
    processBuilder.directory(new File(downloadPath));
    Process process = processBuilder.start();
    process.waitFor();
    
    Thread.sleep(500);
    
    regenerateDefaultPlaylist();

  } 
  catch (IOException e) {
    println(e.getMessage()); 
  }
  catch (InterruptedException e){
    println(e.getMessage());
  }
}

public void getYoutubeMac(String url){
  try {
    String downloadPath = sketchPath("data"); 
    String[] commands = {"/usr/local/bin/yt-dlp", "-o", downloadPath + "/%(title)s.%(ext)s", "--extract-audio", "--audio-format", "mp3", url};
    ProcessBuilder processBuilder = new ProcessBuilder(commands);
    processBuilder.directory(new File(downloadPath));
    Process process = processBuilder.start();
    process.waitFor();
    
    Thread.sleep(500);
    
    regenerateDefaultPlaylist();
    
  } 
  
  catch (IOException e) {
    println("Error: " + e.getMessage()); 
  }
  catch (InterruptedException e){
    println(e.getMessage());
  }
}



public void regenerateDefaultPlaylist(){
  String downloadPath = sketchPath("data");
  File[] songsDataDir = new File(sketchPath("data")).listFiles();
  
  try{
    for(File file: songsDataDir){
      if(file.getName().endsWith(".webm")){
        String inputFile = file.getAbsolutePath();
        String outputFile = inputFile.substring(0, inputFile.length() - 5) + ".mp3";
        // TEMP FILE NAME  

        String[] findCommands = {"which", "ffmpeg"};
        ProcessBuilder findFfmpeg = new ProcessBuilder(findCommands);
        Process runFfmpeg = findFfmpeg.start();
        BufferedReader cmdOutput = new BufferedReader(new InputStreamReader(runFfmpeg.getInputStream()));
        String ffmpegSource = cmdOutput.readLine(); 
        println(ffmpegSource);
        //String ffmpegSource = "/usr/local/bin/ffmpeg";
        //"C:\\Users\\jeffw\\AppData\\Local\\Microsoft\\WinGet\\Packages\\Gyan.FFmpeg_Microsoft.Winget.Source_8wekyb3d8bbwe\\ffmpeg-7.1-full_build\\bin\\ffmpeg.exe"
       
        String[] commands = {ffmpegSource, "-i", inputFile, outputFile};        
        ProcessBuilder processBuilder = new ProcessBuilder(commands);
        processBuilder.directory(new File(downloadPath));
        Process process = processBuilder.start();
        process.waitFor();
      }
    }
  }
  
  catch (IOException e) {
    println(e.getMessage()); 
  }
  catch (InterruptedException e){
    println(e.getMessage());
  }
  
  downloadPath = sketchPath("data");
  songsDataDir = new File(sketchPath("data")).listFiles();
  
  for(File file: songsDataDir){
    if(file.getName().endsWith(".mp3")){
      boolean fileFound = false;
      for(Song song: defaultPlaylist){
        if(file.getName().equals(song.name)){
          fileFound = true;
        }
      }
      if(!fileFound){
        Song tempSong = new Song(this, file.getName(), "TEST ALBUM", "Image.jpeg");
        defaultPlaylist.add(tempSong);
       
      }
    } 
  }
}
class AudioVisualizer{
  float p1, p2;    // top left and bottom right of graph
  int f = 0;
  int amp = 20;
  float lerpIntensity = 0.1f;
  
  float[] prev1 = new float[bands];
  float[] prev2 = new float[bands];
  float[] prev3 = new float[bands];
  float[] prev4 = new float[bands];

  
  AudioVisualizer(float pos1, float pos2){
    this.p1 = pos1;
    this.p2 = pos2;
  }
  
  public void update(){
    fft.input(playlist.get(songIndex).song);
    
    if(f%1==0) fft.analyze(spectrum);
    
    float highestBand = 0;
    float lowestBand = 0;
    for(int i = 0; i < bands; i++){
      if(highestBand > spectrum[i]){
        highestBand = spectrum[i];
      }
      if(spectrum[i] < lowestBand){
        lowestBand = spectrum[i];
      }
    }
    
    float[] reducedSpectrum = new float[bands/2];
    
    for(int i = 0; i < bands; i+=2){
      reducedSpectrum[i/2] = (spectrum[i] + spectrum[i+1]) / 2;
    }
    
    for(int i = 0; i < reducedSpectrum.length; i++){
      reducedSpectrum[i] = lerp(prev1[i], reducedSpectrum[i], lerpIntensity);
    }
    
    for(int i = 0; i < reducedSpectrum.length; i++){
      stroke(50+i, 0, 128 + 2*i);
      strokeWeight(3);
      float newI = map(i, 0, (bands - 1)/2, p1, p2);
      float newY;
      
      if(prev1 != null && prev2 != null && prev3 != null && prev4 != null){
        newY = (reducedSpectrum[i] + prev1[i] + prev2[i] + prev3[i] + prev4[i]) / 5;

      }
      else{
        newY = reducedSpectrum[i];

      }
      strokeWeight(1);
      newY = constrain(newY*amp*400, 0, 250 + random(0, 5));
      ellipse(newI, height - 150, 1, newY);
      int tempWidth = 2;
      if(newI <= p1 + tempWidth || newI >= p2 - tempWidth) tempWidth = 1;
      circle(newI, height - 150, tempWidth);

    }
    
    prev4 = prev3;
    prev3 = prev2;
    prev2 = prev1;
    prev1 = reducedSpectrum;
    
    f++;
  }
}

public void initializePlaylists(){
  //Adding all the songs to defult playlist --> has every song 
  defaultPlaylist.add(new Song(this,"Benzi Box.mp3","Mouse and the Mask", "Mouse and the Mask.jpeg"));
  defaultPlaylist.add(new Song(this,"Doomsday.mp3", "Operation: DOOMSDAY","Operation Doomsday Album Cover.jpeg" ));
  defaultPlaylist.add(new Song(this,"Rhymes Like Dimes.mp3", "Operation: DOOMSDAY","Operation Doomsday Album Cover.jpeg" ));
  defaultPlaylist.add(new Song(this,"Potholderz.mp3", "MM Food","MM Food.jpeg" ));
  defaultPlaylist.add(new Song(this,"Deep Fried Frenz.mp3", "MM Food","MM Food.jpeg" ));
  defaultPlaylist.add(new Song(this,"Crosshairs.mp3", "Mouse and the Mask","Mouse and the Mask.jpeg" ));
  defaultPlaylist.add(new Song(this,"Darling I.mp3","Chromakopia","Chromakopia Album.jpeg" ));
  defaultPlaylist.add(new Song(this,"St Chroma.mp3","Chromakopia","Chromakopia Album.jpeg"));
  defaultPlaylist.add(new Song(this,"See You Again.mp3","Flower Boy","Flower Boy.jpeg"));
  defaultPlaylist.add(new Song(this,"911 Mr lonely.mp3","Flower Boy","Flower Boy.jpeg"));
  defaultPlaylist.add(new Song(this,"Pink White.mp3","Blonde","Blonde.jpeg"));
  defaultPlaylist.add(new Song(this,"Goodbye Angels.mp3","The Getaway","The Getaway.jpeg"));
  defaultPlaylist.add(new Song(this,"Sick Love.mp3","The Getaway","The Getaway.jpeg"));
  defaultPlaylist.add(new Song(this,"White Braids & Pillow Chair.mp3","Unlimited Love","Unlimited Love.jpeg"));
  defaultPlaylist.add(new Song(this,"Black Summer.mp3","Unlimited Love","Unlimited Love.jpeg"));
  defaultPlaylist.add(new Song(this,"Billie Jean.mp3","Thriller","Thriller.jpeg"));


  

  //Setting up  playlist1
  playlist1.add(new Song(this,"Potholderz.mp3", "MM Food","MM Food.jpeg" ));
  playlist1.add(new Song(this,"Black Summer.mp3","Unlimited Love","Unlimited Love.jpeg"));
  playlist1.add(new Song(this,"St Chroma.mp3","Chromakopia","Chromakopia Album.jpeg"));
  playlist1.add(new Song(this,"911 Mr lonely.mp3","Flower Boy","Flower Boy.jpeg"));
  playlist1.add(new Song(this,"Crosshairs.mp3", "Mouse and the Mask","Mouse and the Mask.jpeg" ));
  playlist1.add(new Song(this,"Pink White.mp3","Blonde","Blonde.jpeg"));


  //Setting up playlist2
  playlist2.add(new Song(this,"Rhymes Like Dimes.mp3", "Operation: DOOMSDAY","Operation Doomsday Album Cover.jpeg" ));
  playlist2.add(new Song(this,"Doomsday.mp3", "Operation: DOOMSDAY","Operation Doomsday Album Cover.jpeg" ));
  playlist2.add(new Song(this,"Benzi Box.mp3","Mouse and the Mask", "Mouse and the Mask.jpeg"));
  playlist2.add(new Song(this,"Billie Jean.mp3","Thriller","Thriller.jpeg"));
  playlist2.add(new Song(this,"See You Again.mp3","Flower Boy","Flower Boy.jpeg"));
  playlist2.add(new Song(this, "Crosshairs.mp3", "Mouse and the Mask","Mouse and the Mask.jpeg" ));
  playlist2.add(new Song(this,"Goodbye Angels.mp3","The Getaway","The Getaway.jpeg"));
  playlist2.add(new Song(this,"St Chroma.mp3","Chromakopia","Chromakopia Album.jpeg"));
  playlist2.add(new Song(this, "Darling I.mp3","Chromakopia","Chromakopia Album.jpeg" ));



  
  //Adding all the playlists to 2d array
  allPlaylists.add(defaultPlaylist);
  allPlaylists.add(playlist1);
  allPlaylists.add(playlist2);  
 

  //Adding the playlist names to an arraylist 
  displayNames.add("All Songs");
  displayNames.add("Playlist 1");
  displayNames.add("Playlist 2");

}
public void shufflePlaylist(ArrayList<Song> p){ //Takes in a playlist
    if(p.size() < 2){ //If the playlist is 2 songs than it cannot be shuffled
        return;
    }

    //Resets each song in playlist to make sure it starts from beginning of song 
    for(Song song : p){
      song.reset();
    }

    for(int i = p.size() - 1; i > 0; i--){ //Goes through the size of the playlist
      //Mixes all the songs up by assing random values to then setting the songs at that value
      int j = PApplet.parseInt(random(i+1));
      Song temp = p.get(i);
      p.set(i,p.get(j));
      p.set(j,temp);
    }
   
}

public void deletePlaylist(){ //draws the boxes that surround playlist names and deletes playlists
    int x = 275;
    int y = 50;
    
    boolean playlistDeleted = false;
    
    
    for(int i = allPlaylists.size() - 1; i >= 1; i--){
        drawPlaylist(i, x, y); //Drawing the names of playlist
        
        

        //drawing the boxes 
        noFill();
        strokeWeight(5);
        rect(x-40,y-25, 125,50);
        

        if(mousePressed && mouseX > x-40 && mouseX < x+85 && mouseY > y-25 && mouseY < y+50){ //Checking if the user presses inside the boxes
            //deleting the selected playlist from the list that holds all playlists and from the display names
            allPlaylists.remove(i);
            displayNames.remove(i);
            playlistDeleted = true;
            show_playlist.setItems(displayNames,0); //Updating the drop down menu
            break;
        }

        x += 180; //Updating x value to move boxes over

        if(x > 900){ //Checking to see if x moves past the panal
            x = 275; //Reseting x value
            y += 75; //moving y value down to create a new row
        }
    }

    if (playlistDeleted) {
        mousePressed = false; //If a playlist gets deleted mousePressed goes to false to make user have to click again to delete another playlist
    }  
}

public void drawPlaylist(int i, int x, int y){ //Draws the playlist names when deleting a playlist
    String displayName = displayNames.get(i); //Gets the playlist name to be drawn in correct box
    float fontSize = 16; //set font size
    textSize(fontSize);

    while(textWidth(displayName) > 105){ //Cheking if playlist name is to big to fit in box
        fontSize -= 0.5f; //adjusting font size to fit in the box
        textSize(fontSize); //Setting text size to new font size
    }

    //drawing the playlist names
    fill(0);
    textAlign(CENTER,CENTER);
    text(displayName, x+20, y);

    
}

public void createNewPlaylist(){ //Creating new playlist
    if(selectedSongs.isEmpty()){ //Chekcing if any songs are selected when user presses confirm 
        println("No songs selected!");
        return;
    }

    
    String newPlaylistName = "Playlist " + displayNames.size(); //Creating the playlist name 

    displayNames.add(newPlaylistName); //Adding new playlist name to display name list

    ArrayList<Song> newPlaylist = new ArrayList<Song>(); //Creating new playlist(Arraylist of songs)

    for(Song song : selectedSongs){ //Going through all the selected songs by the user 
        newPlaylist.add(song); //Adding the selected songs to new playlist
    }

    allPlaylists.add(newPlaylist); //Adding new playlist to list of all playlist

    selectedSongs.clear(); //Clearing selected songs

    show_playlist.setItems(displayNames,0); //Updating dropdown menu to have new playlist in it
}

public void playlistCreateDisplay(){ //displaying the screen to create a new playlist
    drawSongs(); //Drawing all the songs so user can select them
    //Setting up x and y values
    int x = 275; 
    int y = 50;  

    for(int i = 0; i < defaultPlaylist.size(); i++){ // going througn all the songs
        Song song = defaultPlaylist.get(i); //Creating a value/song for each song in the defaultPlaylist(All the songs in the program)

        // Check if mouse is over the current song
        if (mousePressed && mouseX > x - 40 && mouseX < x + 85 && mouseY > y - 25 && mouseY < y + 50) {
            if(!selectedSongs.contains(song)){ //Cheking if the song was already clicked by the user
                selectedSongs.add(song); //Adding the selected song into selected song list as to be added to the new playlist
                song.clicked = true; // Mark the song as clicked
                
            }
        }
        // Update position for the next song
        x += 180; 
        if (x > 900) { // Check if the row is full
            x = 275; //reseting x value
            y += 75; //changing y value to make a new row 
        }
    }
}
class Song{
    String name;
    String album; 
    String artWork;
    boolean clicked;
    SoundFile song;
    PImage cover; 
    PImage noCover;

    //CONSTRUCTOR
    Song(PApplet sketch, String n, String a, String aw){
        this.name = n;
        this.album = a;
        this.artWork = aw;
        this.clicked = false;
        this.song = new SoundFile(sketch, n);
        this.cover = sketch.loadImage(aw);
        this.noCover = sketch.loadImage("Image.jpeg");
    }

    public void displayInfo(PApplet sketch){
        String songName = this.name.substring(0,this.name.length()-4); //Removing .mp3 on the file names to get the song names
        float fontSize = 20; //base font size
        sketch.textSize(fontSize); //setting text size to font size

        while(sketch.textWidth(songName) > 215 ){  //Checking if the song name will go out of the skech
            fontSize -= 0.5f; //Makes font size smaller until text fits into the panal
            sketch.textSize(fontSize); //setting text size to the new font size
        }

        sketch.textAlign(LEFT, BASELINE); //centering the text to the panal
        fill(0); //Making the text black
        sketch.text("Album: " + this.album, 935,240); //Drawing the text to the canvas/sketch
        sketch.text("Song: " + songName, 935,265);

        if(cover != null){
            sketch.image(this.cover, 967,20, 200,200); //If there is an album cover, then is will be drawn
        }

        else{
            sketch.image(this.noCover,967,20, 200,200);//if there is no cover, then a set picture will go in its place
        }

        
    }

    public void playSong(float speed, float volume){
        if(playSong){ //If user presses play
            if(!this.song.isPlaying() && !playStatus){ //Checking if a song is already playing
                playStatus = true;
                this.song.play(speed,volume); //Playing song with the requested speed and volume of the user
            }
        } 

        else if(!playSong && playStatus){ //Checking if the user presses pause
            this.song.pause(); //Pauses song
            playStatus = false;
        }
    }

    public void stopSong(){
        if(this.song.isPlaying()){
            this.song.stop(); //Full stoping the song
        }
    }

    public void reset(){
        this.song.stop(); //Full stops the song
        this.song.cue(0.0f); //Resests the song back to 0.0
    }

    public void printSongs(PApplet sketch, int x, int y){ //printing the song name
        
        String displayName = this.name.substring(0, this.name.length()-4); // taking off .mp3 to get the song name

        float fontSize = 16; //base font size
        sketch.textSize(fontSize);

        while(sketch.textWidth(displayName) > 105 ){ //100 is the width of the rect - the edge of rect 
            fontSize -= 0.5f; //Makes font size smaller until text fits into the rectangle
            sketch.textSize(fontSize);
        }

        if(this.clicked && create){ //When the user is creating a playlist and clicks a certain song
            sketch.fill(0,255,0); //Changes the song colour to be green to indicate being selected
        }
        else{
            sketch.fill(0); //Base colour is black 
        }
        
        sketch.textAlign(CENTER,CENTER); //Centers text in the rectangle
        sketch.text(displayName,x+20,y); //displaying the text into the rectangle

        sketch.textAlign(LEFT, BASELINE); //Reseting the text align 
    }

}

/* =========================================================
 * ====                   WARNING                        ===
 * =========================================================
 * The code in this tab has been generated from the GUI form
 * designer and care should be taken when editing this file.
 * Only add/edit code inside the event handlers i.e. only
 * use lines between the matching comment tags. e.g.

 void myBtnEvents(GButton button) { //_CODE_:button1:12356:
     // It is safe to enter your event code here  
 } //_CODE_:button1:12356:
 
 * Do not rename this tab!
 * =========================================================
 */

public void playClicked(GImageButton source, GEvent event) { //_CODE_:play_button:242900:
  if(!delete && !create){ //Cheking if delete or create screen are being displayed --> will not run if one of them are
    playSong = true; //Playing the song when true
    displayPlay = false; //Switiching the play button to a pause button
  } 
} 

public void pauseClicked(GImageButton source, GEvent event) { //_CODE_:pause_button:527890:
  if(!delete && !create){ //Cheking if delete or create screen are being displayed --> will not run if one of them are
    playSong = false; //Pausing the song when pressed
    displayPlay = true; //Switiching the pause button to a play button
  }
} 

public void fastfowardClicked(GImageButton source, GEvent event) { //_CODE_:fast_foward_button:334872:
  if(!delete && !create){ //Cheking if delete or create screen are being displayed --> will not run if one of them are
    playlist.get(songIndex).stopSong(); //getting the current index of playlist(Checking wich song is being played) and stoping the song
    
    if(!isLooping){ //Cheking if the the user wants the song to being looping or not
      songIndex = (songIndex + 1) % playlist.size(); //if not, then the song index gets added by one(goes to next song)(% playlist.size is to keep the playlist looping when it reaches the last song)
    }

    else{
      songIndex = (songIndex) % playlist.size(); //if looping, then song restarts
    }
    
    playStatus = false;
  }
} //_CODE_:fast_foward_button:334872:

public void rewindClicked(GImageButton source, GEvent event) { //_CODE_:rewind_button:710650:
  if(!delete && !create){ //Cheking if delete or create screen are being displayed --> will not run if one of them are
    playlist.get(songIndex).stopSong(); //Stopping the current song
    songIndex = (songIndex-1 + playlist.size()) % playlist.size(); //Setting the songIndex to the last song to play the prevoius song --> if the song is the first in que, then the rewined song will be the last in que
    playStatus = false;
  }
} 

public void loopClicked(GImageButton source, GEvent event) { //Loops and unloops song
  if(!delete && !create){ //Cheking if delete or create screen are being displayed --> will not run if one of them are
    loopIndex += 1; 
    if((loopIndex % 2) == 0){ //Cheking if loop index is odd or even as to be able to loop and unloop with one button
      isLooping = true; //Sets looping to true and turns the button white to indicate looping
      
    }
    else{
      isLooping = false; //Sets looping to false and turns button back to black to indicate NO looping
    }
  }
  
} 

//Need a second button that does the same thing as before but this one is white to show the user that looping is true
public void whiteLoopClicked(GImageButton source, GEvent event) { //Loops and unloops song
  if(!delete && !create){ //Cheking if delete or create screen are being displayed --> will not run if one of them are
    loopIndex += 1;

    if((loopIndex % 2) == 0){
      isLooping = true;
    }
    else{
      isLooping = false;
    }
  }
} 


public void shuffleClicked(GImageButton source, GEvent event) { //_CODE_:shuff_button:228625:
  if(!delete && !create){ //Cheking if delete or create screen are being displayed --> will not run if one of them are
    if(playlist.get(songIndex).song.isPlaying()){ //Checks to see if the current selected song is playing
      playlist.get(songIndex).stopSong(); //Stops the song if it is being played 
    }

    shufflePlaylist(playlist); //Puts playlist to be shuffledn
    songIndex = 0; //Resets the song index to 0 --> resets the que 

    //When shuffle is pressed it also plays the songs acting like a play button aswell 
    playStatus = false; 
    playSong = true;
    displayPlay = false;
    
    redraw();//redrawing all the song names and boxes to match up with the shuffled que/order of songs
  }

} 

public void speedChanged(GSlider source, GEvent event) { //_CODE_:speed_slider:867952:
  if(!delete && !create){ //Cheking if delete or create screen are being displayed --> will not run if one of them are
    float displaySpeed = speed_slider.getValueF(); //getting values from the slider

    playBackSpeed = map(displaySpeed, 0.0f,2, 0.6f, 1.4f); //Mapping the values of the slider to new values to make it sound better when slowed down and sped up
    if(playlist.get(songIndex).song.isPlaying()){
      playlist.get(songIndex).song.rate(playBackSpeed); //Changing the rate/speed of the song to match up with the slider
    }
  }
  
} 

public void volumeChanged(GSlider source, GEvent event) { //_CODE_:volume:779657:
  if(!delete && !create){ //Cheking if delete or create screen are being displayed --> will not run if one of them are
    float displayVolume = volume.getValueF();//getting values from the slider

    setVolume = map(displayVolume, 0,10, 0.0f,3.0f); //mapping the values to avoid glitching of the song

    if(playlist.get(songIndex).song.isPlaying()){
      playlist.get(songIndex).song.amp(setVolume); //Changing the volume of the song to match up with the slider 
    }
  }
} 

public void show_playlistClicked(GDropList source, GEvent event) { //_CODE_:dropList1:447654:
  if(!delete && !create){ //Cheking if delete or create screen are being displayed --> will not run if one of them are
    selectedIndex = source.getSelectedIndex(); //Getting the index of the selected box in the dropdown menu
  
    setActivePlaylist(selectedIndex); //Setting the selected playlist as the current/active playlist 
  }
} //_CODE_:dropList1:447654:

 public void youtubeUrlChanged(GTextField source, GEvent event) { //_CODE_:YoutubeUrl:779815:
   youtubeURL = youtubeUrl.getText(); //Getting the text from the text field
 } //_CODE_:YoutubeUrl:779815:

 public void youtubeCommitClicked(GButton source, GEvent event) { //_CODE_:youtubeCommit:244925:
   getYoutubeWindows(youtubeURL); //Calling getYoutubeWindows to download the song
 } //_CODE_:youtubeCommit:244925:

public void createPlaylistClicked(GButton source, GEvent event) { //_CODE_:createPlaylist:727161:
   if(!delete){ //Cheking if delete screen is being displayed --> will not run if it is
     setActivePlaylist(0); //Displays defaultPlaylist(Displays this playlist since it hold all the songs in the program)
     create = true; //Setting create to true to indicate to the rest of the program that it is on the create screen
   }
  } //_CODE_:createPlaylist:727161:

public void deletePlaylistClicked(GButton source, GEvent event) { //_CODE_:deletePlaylist:748042:
  if(!create){ //Cheking if create screen is being displayed --> will not run if it is
   delete = true; //Setting delete as true to indicate to the rest of the program this it is on the delete playlist screen
   playSong = false; //Pauses the song
   displayPlay = true; //Displaying the Play button to replace pause button if it is on the screen

  }
} 

public void returnClicked(GButton source, GEvent event){ //For returning to the normal screen from either the delete or create playlist screen
  delete = false; //setting delete to false
  create = false; //setting create to false
  if(selectedIndex == allPlaylists.size()){ //if the prevoiusly selected playlist was deleted, user gets returned to the all songs screen
    setActivePlaylist(0);
  }
  else{
    setActivePlaylist(selectedIndex); //Other wise the user gets returned to their past playlist
  }
  

  
}

public void confirmButtonClicked(GButton source, GEvent event){ //Similair to return button 
  delete = false;  //setting delete to false
  create = false; //setting create to false
  for(Song song : defaultPlaylist){ //goes through all the songs in default playlist to unselect them/ go from green text back to black
    song.clicked = false;  // Resets all songs to unselected
  }
  createNewPlaylist(); //creates the new playlist
  setActivePlaylist(selectedIndex); //returns user to their past playlist
}


// Create all the GUI controls. 
// autogenerated do not edit
public void createGUI(){
  G4P.messagesEnabled(false);
  G4P.setGlobalColorScheme(GCScheme.BLUE_SCHEME);
  G4P.setMouseOverEnabled(false);
  surface.setTitle("Sketch Window");
  play_button = new GImageButton(this, 600, 505, 60, 50, new String[] { "Black Play Button.png", "Black Play Button.png", "Black Play Button.png" } );
  play_button.addEventHandler(this, "playClicked");
  pause_button = new GImageButton(this, 575, 495, 100, 70, new String[] { "Black Pause Button.png", "Black Pause Button.png", "Black Pause Button.png" } );
  pause_button.addEventHandler(this, "pauseClicked");
  fast_foward_button = new GImageButton(this, 670, 505, 60, 50, new String[] { "Fast Forward Button.png", "Fast Forward Button.png", "Fast Forward Button.png" } );
  fast_foward_button.addEventHandler(this, "fastfowardClicked");
  rewind_button = new GImageButton(this, 520, 505, 60, 50, new String[] { "Rewind Button.png", "Rewind Button.png", "Rewind Button.png" } );
  rewind_button.addEventHandler(this, "rewindClicked");
  loop_button = new GImageButton(this, 320, 485, 100, 100, new String[] { "Black Loop Button.png","Black Loop Button.png" , "Black Loop Button.png" } );
  loop_button.addEventHandler(this, "loopClicked");
  loop_buttonWhite = new GImageButton(this, 320, 485, 100, 100, new String[] { "White Loop Button.png", "White Loop Button.png", "White Loop Button.png" } );
  loop_buttonWhite.addEventHandler(this, "whiteLoopClicked");
  shuff_button = new GImageButton(this, 420, 505, 100, 60, new String[] { "shuffle.png", "shuffle.png", "shuffle.png" } );
  shuff_button.addEventHandler(this, "shuffleClicked");
  speed_slider = new GSlider(this, 780, 480, 100, 50, 10.0f);
  speed_slider.setShowValue(true);
  speed_slider.setShowLimits(true);
  speed_slider.setLimits(1.0f, 0.1f, 2.0f);
  speed_slider.setNbrTicks(5);
  speed_slider.setStickToTicks(false);
  speed_slider.setShowTicks(false);
  speed_slider.setNumberFormat(G4P.DECIMAL, 1);
  speed_slider.setOpaque(false);
  speed_slider.addEventHandler(this, "speedChanged");
  volume = new GSlider(this, 780, 530, 100, 50, 10.0f);
  volume.setShowValue(true);
  volume.setShowLimits(true);
  volume.setLimits(3, 0.0f, 10);
  volume.setNbrTicks(10);
  volume.setStickToTicks(false);
  volume.setShowTicks(false);
  volume.setNumberFormat(G4P.DECIMAL, 2);
  volume.setOpaque(false);
  volume.addEventHandler(this, "volumeChanged");
  show_playlist = new GDropList(this, 30, 200, 150, 150, allPlaylists.size(), 15);
  show_playlist.setItems(displayNames,0);
  show_playlist.addEventHandler(this, "show_playlistClicked");
  createPlaylist = new GButton(this, 30, 275, 150, 25);
  createPlaylist.setText("Create Playlist"); 
  createPlaylist.addEventHandler(this, "createPlaylistClicked");
  deletePlaylist = new GButton(this, 30, 325, 150, 25);
  deletePlaylist.setText("Delete Playlist");
  deletePlaylist.addEventHandler(this, "deletePlaylistClicked");
  returnButton = new GButton(this, 220, 415, 100, 25);
  returnButton.setText("Return");
  returnButton.addEventHandler(this,"returnClicked");
  confirmButton = new GButton(this, 815, 415, 100, 25);
  confirmButton.setText("Confirm");
  confirmButton.addEventHandler(this, "confirmButtonClicked");
  youtubeUrl = new GTextField(this, 30, 425, 150, 25, G4P.SCROLLBARS_NONE);
  youtubeUrl.setPromptText("Enter Url here");
  youtubeUrl.setOpaque(true);
  youtubeUrl.addEventHandler(this, "youtubeUrlChanged");
  youtubeCommit = new GButton(this, 30, 475, 150, 25);
  youtubeCommit.setText("Youtube Commit");
  youtubeCommit.addEventHandler(this, "youtubeCommitClicked");
 
}



// Variable declarations 
// autogenerated do not edit
GImageButton play_button; 
GImageButton pause_button; 
GImageButton fast_foward_button; 
GImageButton rewind_button; 
GImageButton loop_button; 
GImageButton shuff_button; 
GSlider speed_slider; 
GSlider volume; 
GDropList show_playlist; 
GImageButton loop_buttonWhite; 
GButton createPlaylist; 
GButton deletePlaylist; 
GButton returnButton;
GTextField youtubeUrl; 
GButton youtubeCommit; 
GButton confirmButton;


  public void settings() { size(1200, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Processing" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
